<!DOCTYPE html>
<html lang="en">
<!-- Beautiful Jekyll 5.0.0 | Copyright Dean Attali 2020 -->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  

  

  <title>Tổng quan về ECC</title>

  
  <meta name="author" content="Ngô Tấn Trí">
  

  <meta name="description" content="ECC">

  

  

  <link rel="alternate" type="application/rss+xml" title="Em0t3t" href="http://localhost:4000/feed.xml">

  

  

  


  
    
      
  <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">


    
      
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic">


    
      
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800">


    
  

  
    
      <link rel="stylesheet" href="/assets/css/bootstrap-social.css">
    
      <link rel="stylesheet" href="/assets/css/beautifuljekyll.css">
    
  

  

  
  
  

  

  
  <meta property="og:site_name" content="Em0t3t">
  <meta property="og:title" content="Tổng quan về ECC">
  <meta property="og:description" content="ECC">

  
  <meta property="og:image" content="http://localhost:4000/assets/img/path.jpg">
  

  
  <meta property="og:type" content="article">
  <meta property="og:article:author" content="Ngô Tấn Trí">
  <meta property="og:article:published_time" content="2021-01-03T00:00:00+00:00">
  <meta property="og:url" content="http://localhost:4000/2021-01-03-ECC/">
  <link rel="canonical" href="http://localhost:4000/2021-01-03-ECC/">
  

  
  <meta name="twitter:card" content="summary_large_image">
  
  <meta name="twitter:site" content="@daattali">
  <meta name="twitter:creator" content="@daattali">

  <meta property="twitter:title" content="Tổng quan về ECC">
  <meta property="twitter:description" content="ECC">

  
  <meta name="twitter:image" content="http://localhost:4000/assets/img/path.jpg">
  

  


  

  

</head>


<body>

  


  <nav class="navbar navbar-expand-xl navbar-light fixed-top navbar-custom top-nav-regular"><a class="navbar-brand" href="http://localhost:4000/">Em0t3t</a><button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  <div class="collapse navbar-collapse" id="main-navbar">
    <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link" href="/aboutme">About Me</a>
          </li>
          <li class="nav-item dropdown">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Resources</a>
            <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                  <a class="dropdown-item" href="https://beautifuljekyll.com">Beautiful Jekyll</a>
                  <a class="dropdown-item" href="https://www.markdowntutorial.com/">Learn markdown</a>
            </div>
          </li>
        
          <li class="nav-item">
            <a class="nav-link" href="https://deanattali.com">Author's home</a>
          </li></ul>
  </div>

  

  
    <div class="avatar-container">
      <div class="avatar-img-border">
        <a href="http://localhost:4000/">
          <img alt="Navigation bar avatar" class="avatar-img" src="/assets/img/LOGODUT.png" />
        </a>
      </div>
    </div>
  

</nav>


  <!-- TODO this file has become a mess, refactor it -->






  <div id="header-big-imgs" data-num-img=1
    
    
    
      
      data-img-src-1="http://localhost:4000/assets/img/path.jpg"
    
    
    
  ></div>


<header class="header-section has-img">

<div class="big-img intro-header">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>Tổng quan về ECC</h1>
          
            
              <h2 class="post-subheading">ECC</h2>
            
          

          
            <span class="post-meta">Posted on January 3, 2021</span>
            
            
          
        </div>
      </div>
    </div>
  </div>
  <span class='img-desc'></span>
</div>

<div class="intro-header no-img">
  <div class="container-md">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
        <div class="post-heading">
          <h1>Tổng quan về ECC</h1>
          
            
              <h2 class="post-subheading">ECC</h2>
            
          

          
            <span class="post-meta">Posted on January 3, 2021</span>
            
            
          
        </div>
      </div>
    </div>
  </div>
</div>
</header>





<div class=" container-md ">
  <div class="row">
    <div class=" col-xl-8 offset-xl-2 col-lg-10 offset-lg-1 ">

      

      

      <article role="main" class="blog-post">
        <style type="text/css">
code.has-jax {font: inherit; font-size: 100%; background: inherit; border: inherit;}
</style>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'] // removed 'code' entry
    }
});
MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_HTML-full"></script>

<hr />
<h1 id="lời-mở-đầu">Lời mở đầu</h1>

<p>Tháng 3 năm 2016, Bộ Ngoại Giao Hoa Kỳ, đứng đầu là bộ trưởng John , đã dẫn một đoàn đại biểu tới các nước ASEAN trong đó có Việt Nam để thảo luận về phát triển Fintech và đặc biệt là về công nghệ Blockchain. Tháng 9 năm 2015, Ủy ban giao dịch hàng hóa tương lai Mỹ công bố, Bitcoin đã chính thức được đưa vào danh sách hàng hóa được phép giao dịch tại Mỹ. Công nghệ Blockchain và Bitcoin là công nghệ tiền số ra đời năm 2009 và ngày càng có nhiều quốc gia và các tổ , doanh nghiệp cho phép lưu hành và thanh toán bằng loại tiền số này trong không gian mạng Internet toàn cầu. Tháng 4-2016, giá trị thương mại của Bitcoin đã lên đến 6.5 tỷ 	USD. Nền tảng cơ sở của Bitcoin chính là lý thuyết về mật mã mà cụ thể ở đây là hàm băm và lý thuyết về chữ ký số dựa trên Hệ thống đường cong Elliptic (ECC).</p>

<p>Bên cạnh việc sử dụng trong tiền số , ECC còn được ứng dụng rất nhiều trong thực tiễn ngành Công nghệ thông tin. Các trang Web bảo mật https (http-secure) thường được dùng trong thanh toán điện tử hay ứng dụng riêng tư như gmail đều sử dụng các giao thức TLS (Transport Layer Security) mà trước đó là SSL (Secure Socket Layer). Trong các giao thức này ECC được sử dụng để trao đổi khóa phiên. Các giao dịch remote access được sử dụng rất nhiều trong thế giới UNIX, LINUX là SSH (Secure SHell) cũng sử dụng ECC để trao đổi khóa. Ưu điểm của hệ mật sử dụng đường cong Elliptic (ECC) là có độ dài khóa nhỏ (160 bit tương đương với khóa độ dài 1024 bit trong hệ mật RSA), do sử dụng độ dài khóa nhỏ nên tài nguyên phục vụ cho ECC thường nhỏ hơn rất , bên cạnh đó hiệu năng tính toán cũng được nâng cao rõ rệt. Hiện nay ECC đang là xu thế để thay thế RSA.</p>

<ul>
  <li>
    <p>Cơ sở toán học của hệ mật ECC là nhóm giao hoán Abel các điềm nằm trên đường cong Elliptic. Ngoài việc đường cong Elliptic là cơ sở cho hệ mật ECC, hệ mật ID-, đường cong Elliptic (EC) còn là công cụ hữu hiệu để phân tích số nguyên ra thừa số nguyên tố, hoặc dùng để kiểm tra tính nguyên tố của số . EC cũng là cơ sở để chứng minh định lý Fermat nổi tiếng đã tồn tại nhiều trăm năm qua.</p>
  </li>
  <li>
    <p>Đường cong Elliptic là một trường hợp đặc biệt của phương trình Diophant. Lý thuyết về đường cong Elliptic (EC) rất phong phú và độ sộ. Trong cuôn sách “Elliptic Curves Diophantine Analysic”, tác giả Serge Lang đã phát biểu về phương diện học thuật: “Có thể viết vô tận về đường cong “. Các lý thuyết và khái niệm liên quan tới EC có thể liệt kê một số như dưới đây:</p>
  </li>
  <li>
    <p>Lý thuyết nhóm, vành, trường trong đại số trừu</p>
  </li>
  <li>
    <p>Đa tạp Affine, đa tạp Jacobian và đa tạp xạ ảnh trong hình học đại số</p>
  </li>
  <li>
    <p>Điểm Torison, Divisor, cặp song tuyến tính Weil, Tate - Lichtenbaum</p>
  </li>
  <li>
    <p>Lý thuyết trường Galois, tự đồng cấu- ánh xạ Frobenius</p>
  </li>
  <li>
    <p>Lý thuyết Baker-Feldman, Baker-Tijdeman và lý thuyết Kummer</p>
  </li>
  <li>
    <p>Số p-adic, Isogenies, hàm Sigma và hàm Zeta</p>
  </li>
  <li>
    <p>Nhóm đối đồng điều, đối đồng điều Galois và đối đồng điều phi giao hoán (Topo đại số)</p>
  </li>
  <li>
    <p>Nhóm Mordell-Weil, Selmer và nhóm Shafaverich-Tate</p>
  </li>
  <li>
    <p>Phương pháp hình học và Tựa tuyến tính (Quasilinear)</p>
  </li>
</ul>

<p>Với ý nghĩa to lớn về cả thực tiễn và học thuật, EC là nền tảng toán học quan trọng trong đại số hiện đại cũng như lý thuyết mật mã hiện tại. EC cũng là nền tảng quan trọng trong chính phủ điện tử và thường mại điện . Chính vì những điều này mà Chuyên đề “Hệ mật mã khóa công khai dựa trên đường cong Elliptic” được lựa chọn để trình bày báo cáo.</p>

<p>Với khối lượng kiến thức và khái niệm đồ sộ như đã liệt kê ở trên việc nghiên cứu và đào sâu về đường cong Elliptic gặp không ít khó khăn cho những người làm Công nghệ thông tin (CNTT) mà toán học không phải là chuyên môn chính. Mục tiêu của chuyên đề này là tổng hợp những khái niệm và kiến thức cơ bản nhất của EC liên quan đến cơ sở toán học của Hệ mật dựa trên đường cong Elliptic. Đồng thời người viết cũng chứng minh lại một số định lý và bổ đề theo cách dễ hiểu hơn, tránh dùng đến các khái niệm quá phức tạp và xa lạ với chuyên nghành CNTT…</p>

<p>Phạm vi của chuyên đề cũng được giới hạn với những khái niệm và lý thuyết đủ cho các ứng dụng cơ bản của EC, các phát triển của EC thành hệ mật ID-based, hoặc các ứng dụng cơ bản của EC, các phát triển của EC thành hệ mật ID-based, hoặc các ứng dụng về chữ ký số tập thể, chữ ký số nhóm, chữ kỹ ngưỡng, chữ ký ủy nhiệm, chữ ký số mù sẽ không được đề cập đến trong khuôn khổ của báo cáo này.</p>

<p>Báo cáo chuyên đề được kết cấu thành 02 chương, chương 1 trình bày các khái niệm, định nghĩa cơ bản về đường cong Elliptic (Phương trình của EC, nhóm cộng Abel các điểm trên đường cong, chứng minh định lý về nhóm…). Chương 2 trình bày về Hệ mật dựa trên đường cong Elliptic và một số ứng dụng trong mã hóa, xác thực chữ ký số, trao đổi khóa dựa trên bài toán khó Logarithm rời rạc.</p>

<p>…
 To be continued</p>

<hr />

<p>Toàn bộ nội dung trên đây được trích từ chuyên đề: “Hệ mật mã khóa công khai dựa trên đường cong Elliptic - Tổng quan về hệ mật mã khóa công khai” của tác giả Đăng Minh Tuấn - Trong tạp chí Epsilon - Số 09 - Tháng 06/2016</p>

<p>P/s: Những phần tiếp theo trong bài báo này khá cao cấp, nên mình tạm dừng ở đây, vào có dịp sẽ quay lại</p>

<p>Link pdf: <a href="http://quantri.thcsthanhxuan.edu.vn///data/thcsthanhxuan/thcsthanhxuan/attachments/2020_8/tap_chi_epsilon_so_09_118202011.pdf">Tại đây</a></p>

<hr />

<h2 id="elliptic-curve">ELLIPTIC CURVE</h2>

<h3 id="overview">OVERVIEW</h3>

<p>The use of elliptic curves for public-key cryptography was first suggested in 1985. After resisting decades of attacks, they started to see widespread use from around 2005, providing several benefits over previous public-key cryptosystems such as RSA.</p>

<p>Smaller EC keys offer greater strength, with a 256-bit EC key having the same security level as a 3072-but RSA key. Furthermore, several operations using those keys( including signing) can be more efficient both time- and memory-wise. Finally, since ECC is more complex than RSA, it has the welcome effect of encouraging developers to make use of trusted libraries rather than rolling their own.</p>

<p>This course is aimed to give you an intuition for the trapdoor function behind ECC ; dip your toes into the mathematical structure underlying it; and have you breaking popular schemes like ECDSA.</p>

<h3 id="background-reading">Background Reading</h3>

<p>Elliptic Curve Cryptography (ECC) is an asymmetric cryptographic protocol that, like RSA and Diffie-Hellman (DH), relies on a trapdoor function. To recap: trapdoor function allow a client to keep data secret by performing a mathematical operation which is computationally easy to do, but currently understood to be very expensive to undo.</p>

<p>For RSA, the trapdoor function relies on the hardness of factoring large numbers . For Diffie-Hellman, the trapdoor relies on the hardness of the discrete log problem. For both RSA and DH, the operations that run through the veins of the protocol are familiar to us. Multiplying numbers and taking powers of number are things we are taught to do in school. ECC stands out, because the group operation in ECC won’t pop up in your life unless you are looking for it.</p>

<p>Note: This discussion here will not be total, and those who are really looking to understand ECC, I recommend these notes <a href="https://crypto.stanford.edu/pbc/notes/elliptic/">Elliptic Curve notes by Ben Lynn</a>, and the textbook “An Introduction to Mathematical Cryptography”, Jeffrey Hoffstein, Jill Pipher, Joseph H. Silverman.</p>

<p>Let’s start thinking anout ECC by looking at what we mean by an elliptic curve. We will be studying <code class="language-plaintext highlighter-rouge">Weierstrass equations</code>, which are of the form $Y^2 = X^3+aX+b$</p>

<p>Elliptic curves have an amazing feature: We can define an operation that we will call “point addtion”. This operation takes two point on some curve and produces a third point on the curve. Taking the set of points on an elliptic curve, point addition defines an Abelian group operation.</p>

<p>Note: There’s a lot of text here. Let’s motivate this ! We can understand scalar multiplication of a point as the repeated point addtion of the same point. $Q=2P=P+P$. It turns out that scalar multiplication is a trapdoor function ! ECC relies on the hardness of finding the $n$ such that $Q=nP$ given Q and P.</p>

<h4 id="so-how-do-we-understand-point-addtion-">So how do we understand point addtion ?</h4>

<p>Geometrically, we can understand point addtion $P+Q$ like so. Take an elliptic curve and mark the two points $P,Q$ along the curve with their $x,y$ coordinates. Draw a straight line that passes through both points. Now continue the line until it intersects your curve a third time. Make this new intersection $R$. Finally, take $R$ and reflect it along the $y$ direction to produce $R’=R(x,-y)$. The result of the point addtion is $P+Q=R’$.</p>

<p>What if we want to add two of the same point together: $P+P$ ? . We can’t draw a unique line through one point, but we can pick a unique line by calculating the tangent line to the curve at the point. Calculate the tangent line at the point $P$. Continue the line until it intersects with the curve at point $R$. Reflect this point as before: $P+P=R’=R(x,-y)$.</p>

<p>What happens if there is no third intersections ? Sometimes you will pick two points $P,Q$ and the line will not touch the curve again. In this case we say that the line intersects with the point (O) which is a single point located at the end of every vertical line at infinity. As such, point addtion for an elliptic curve is defined in 2D space, with an addition point located at infinity.</p>

<p>Included below is a diagram as a visual aid to these different cases: <code class="language-plaintext highlighter-rouge">diagram of ECC addtion</code></p>

<p>The point <code class="language-plaintext highlighter-rouge">0</code> acts as the identity operator of the group: $P+0=P$ and $P+(-P)=0$</p>

<p>This brings us to the point of defining an elliptic curve.</p>

<p><code class="language-plaintext highlighter-rouge">Definition</code>: An elliptic curve E is the set of solutions to a <code class="language-plaintext highlighter-rouge">Weierstrass equation</code>:$E:Y^2=X^3+aX+b$ together with a point at infinity $0$. The constant $a,b$ must be satisfy the relationship: $4a^3+27b^2 \ne 0$</p>

<p>to ensure there are no singularities on the curve.</p>

<p>Formally, let $E$ be an eliiptic curve, point addtion has the following properties:</p>

<p><code class="language-plaintext highlighter-rouge">(a) P+0 = 0+P=P</code></p>

<p><code class="language-plaintext highlighter-rouge">(b) P + (-P) = 0</code></p>

<p><code class="language-plaintext highlighter-rouge">(c) (P+Q) + R = P + (Q+R)</code></p>

<p><code class="language-plaintext highlighter-rouge">(d) P + Q = Q + P</code></p>

<p>In ECC, we study elliptic curves over a finite field $F_p$. This means we look at the curve modulo the characteristic <code class="language-plaintext highlighter-rouge">p</code> and an elliptic curve will no longer be a curve, but a collection of points whose <code class="language-plaintext highlighter-rouge">x,y</code> coordinates are integers in $F_p$</p>

<p>The following starter challenges will take you through the calculations for ECC and get you used to the basic operation that ECC is built upon, have fun !</p>

<p>Property $(d)$ shows that point addtion is communicative. The flag is the name we give groups with a commutative operation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag: Crypto{Abelian}
</code></pre></div></div>

<h3 id="point-negation">POINT NEGATION</h3>

<p>In the background section, we covered the basics of how we can view point addtion over an elliptic curve as being an abelian group operation. In this geometric picture we allowed the coordinations on the curve to be any real number.</p>

<p>To apply elliptic curves in a cryptographic setting, we study elliptic curves which have coordinates in a finite field $F_p$</p>

<p>We will still be considering elliptic curves of the form: $E:Y^2=X^3+aX+b$, which satisfy the following conditions: $a,b\in F_p$ and $4a^3+27b^2\ne 0$. However, we no longer think of the elliptic curve as a geometric object, but rather a set of points defined by:</p>

<p>$E(F_p)=${$(x,y)\in F_p$ satisfying: $y^2=x^3+ax+b$}$\cup O$</p>

<p>Note: Everything we covered in the background still holds. The identity of the group is the point at infinity: O, and the addition law is unchanged. Given two point $E(F_p)$, the addition law will generate another point in $E(F_p)$</p>

<p>For all the challenges in the start set, we will be working with the elliptic curve</p>

<p>$E:Y^2=X^3+497X+1768,p:9739$</p>

<p>Using the above curve, and the point $P(8045,6936)$, find the point $Q(x,y)$ such that $P+Q=0$</p>

<p>Note: Remember, we’re working in a finite now, so you’ll need to work correctly with negative numbers.</p>

<p>This is solution:</p>

<p>We have $P+Q = 0 \implies Q=-P=(8045,-6936)$ (mod <code class="language-plaintext highlighter-rouge">p</code>)</p>

<p>$\implies Q(8045,-6936+9739)$</p>

<p><img src="https://i.imgur.com/pKFXEz8.png" alt="Imgur" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag: crpyto{8045,2803}
</code></pre></div></div>

<h3 id="point-addition">POINT ADDITION</h3>

<p>While working with elliptic curve cryptography, we will need to add points together. In the background challenges, we did this geometrically by finding a line that passed through two points, finding the third intersection and then reflecting along the y-axis</p>

<p><img src="https://i.imgur.com/Z9GTPCg.png" alt="Imgur" /></p>

<p>It turns out that there is an efficient algorithm for calculating the point addtion law for an elliptic curve.</p>

<p><code class="language-plaintext highlighter-rouge">Taken from "An Introduction to Mathematical Cryptography", Jeffrey Hoffstein, Jill Pipher, Joseph H. Silverman, the following algorithm will calculate the addition of two points on an elliptic curve</code></p>

<h5 id="algorithm-for-the-addition-of-two-points-pq">Algorithm for the addition of two points: P+Q</h5>

<p>(a) If P=O, then P+Q=Q</p>

<p>(b) Otherwise, if Q=O, then P+Q=P</p>

<p>(c) Otherwise, write $P=(x_1,y_1)$ and $Q=(x_2,y_2)$</p>

<p>(d) If $x_1=x_2$ and $y_1=-y_2$ then $P+Q=O$</p>

<p>(e) Otherwise:</p>

<ul>
  <li>
    <p>(e1) if $P\ne Q:\lambda = (y_2-y_1)/(x_2-x_1)$</p>
  </li>
  <li>
    <p>(e2) if $P=Q:\lambda = (3x_1^2+a)/2y_1$</p>
  </li>
</ul>

<p>(f) $x_3 = \lambda^2-x_1-x_2,y_3 = \lambda(x_1-x_3)-y_1$</p>

<p>(g) $P+Q=(x_3,y_3)$</p>

<p>Note: We are working with a finite field, so the above calculation should be donw <code class="language-plaintext highlighter-rouge">mod p</code>, and we do not “divide” by an integer, we instead multiply by the modular inverse of a number. e.g. <code class="language-plaintext highlighter-rouge">1/5 = 9 mod 11</code></p>

<p>We will work with the following elliptic curve, and prime:</p>

<p>$E:Y^2 = X^3+497x+1769,P:9739$</p>

<p>Note: You can test your algorithm by asserting: <code class="language-plaintext highlighter-rouge">X + Y = (1024, 4440)</code> and <code class="language-plaintext highlighter-rouge">X + X = (7284, 2107)</code> for <code class="language-plaintext highlighter-rouge">X = (5274, 2841)</code> and <code class="language-plaintext highlighter-rouge">Y = (8669, 740)</code></p>

<p>Using the above curve, and the points <code class="language-plaintext highlighter-rouge">P = (493, 5564), Q = (1539, 4742), R = (4403,5202)</code>, find the point <code class="language-plaintext highlighter-rouge">S(x,y) = P + P + Q + R</code> by implemented the above algorithm</p>

<p>Note: After calculating <code class="language-plaintext highlighter-rouge">S</code>, substitute the coordinates into the curve. Assert that the point <code class="language-plaintext highlighter-rouge">S</code> is in $E(F_p)$</p>

<p>This is my solution</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">Crypto.Util.number</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">inf</span> <span class="o">=</span> <span class="mi">1000000000000000000</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">9739</span> 
<span class="n">O</span> <span class="o">=</span> <span class="p">(</span><span class="n">inf</span><span class="o">%</span><span class="n">p</span><span class="p">,</span><span class="n">inf</span><span class="o">%</span><span class="n">p</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sqr_mod</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">%</span><span class="n">p</span>
<span class="k">def</span> <span class="nf">addition_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">497</span>
    <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="o">==</span><span class="n">O</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Q</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="o">==</span><span class="n">O</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">P</span> 
    <span class="n">x_1</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_1</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x_2</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_2</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x_1</span><span class="o">==</span><span class="n">x_2</span> <span class="ow">and</span> <span class="n">y_1</span><span class="o">+</span><span class="n">y_2</span><span class="o">%</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">O</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="o">!=</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">lamda1</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_2</span> <span class="o">-</span> <span class="n">y_1</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_2</span> <span class="o">-</span> <span class="n">x_1</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="n">inverse</span><span class="p">(</span><span class="n">lamda2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
        <span class="n">lamda</span> <span class="o">=</span> <span class="n">lamda1</span><span class="o">*</span><span class="n">lamda2</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">x_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqr_mod</span><span class="p">(</span><span class="n">lamda</span><span class="p">)</span><span class="o">-</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span>
        <span class="n">y_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">lamda</span><span class="o">*</span><span class="p">((</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_3</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">-</span><span class="n">y_1</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="k">return</span> <span class="p">(</span><span class="n">x_3</span><span class="p">,</span><span class="n">y_3</span><span class="p">)</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="o">==</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">lamda1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">sqr_mod</span><span class="p">(</span><span class="n">x_1</span><span class="p">)</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y_1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="n">inverse</span><span class="p">(</span><span class="n">lamda2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
        <span class="n">lamda</span> <span class="o">=</span> <span class="n">lamda1</span><span class="o">*</span><span class="n">lamda2</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">x_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqr_mod</span><span class="p">(</span><span class="n">lamda</span><span class="p">)</span><span class="o">-</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span>
        <span class="n">y_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">lamda</span><span class="o">*</span><span class="p">((</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_3</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">-</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="k">return</span> <span class="p">(</span><span class="n">x_3</span><span class="p">,</span><span class="n">y_3</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5274</span><span class="p">,</span> <span class="mi">2841</span><span class="p">)</span> 
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8669</span><span class="p">,</span> <span class="mi">740</span><span class="p">)</span>

<span class="c1"># tmp = addition_point(X,X,497)
# print(tmp)
</span><span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">493</span><span class="p">,</span> <span class="mi">5564</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1539</span><span class="p">,</span> <span class="mi">4742</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4403</span><span class="p">,</span><span class="mi">5202</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">addition_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">addition_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">addition_point</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">R</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag: crypto{4215, 2162}
</code></pre></div></div>

<h3 id="scalar-multiplication">Scalar Multiplication</h3>

<p>Scalar multiplication of two points is defined by repeated addtion: $3P=P+P+P$</p>

<p>In the next few challenges, we will use scalar multiplication to create a shared secret over an insecure channel similarly to Diffie-Hellman challenges.</p>

<p>Taken from ` “An Introduction to Mathematical Cryptography”, Jeffrey Hoffstein, Jill Pipher, Joseph H. Silverman` , the following algorithm will efficiently calculate scalar multiplication of a point on an elliptic curve</p>

<h4 id="double-and-add-algorithm-for-the-scalar-multilication-of-point-by-n">Double and Add algorithm for the scalar multilication of point by n.</h4>

<p>Input: P in $E(F_p)$ and an integer $n&gt;0$</p>
<ol>
  <li>Set $Q=P$ and $R=O$</li>
  <li>Loop while $n&gt;0$</li>
  <li>if n = 1 mod 2, R=R+Q</li>
  <li>Set Q = 2 Q and n = [n/2]
 5 if n&gt;0, continue with loop at Step 2</li>
  <li>Return the point R, which equal nP</li>
</ol>

<p>Note: This is not the most efficient algorithm, there are many interesting ways to improve this calculation up, but this will be sufficient for our work</p>

<p>We will work with the following elliptic curve, and prime:</p>

<p>$Y^2 = X^3+497X+1768,p=9739$</p>

<p>Note: You can test your algorithm by asserting: $1337X = (1089,6931)$ for $X=(5323,5438)$</p>

<p>Using above curve, and the points <code class="language-plaintext highlighter-rouge">P = (2339, 2213)</code>, find the point Q(x,y) = 7863 P by implementing the above algorithm</p>

<p>Note: After calculating Q, substitute the coordinates into the curve. Assert that the point $Q$ is in $E(F_p)$</p>

<p>This is my sol</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">Crypto.Util.number</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">inf</span> <span class="o">=</span> <span class="mi">1000000000000000000</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">9739</span> 
<span class="n">O</span> <span class="o">=</span> <span class="p">(</span><span class="n">inf</span><span class="o">%</span><span class="n">p</span><span class="p">,</span><span class="n">inf</span><span class="o">%</span><span class="n">p</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sqr_mod</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">%</span><span class="n">p</span>
<span class="k">def</span> <span class="nf">addition_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">497</span>
    <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="o">==</span><span class="n">O</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Q</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="o">==</span><span class="n">O</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">P</span> 
    <span class="n">x_1</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_1</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x_2</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_2</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x_1</span><span class="o">==</span><span class="n">x_2</span> <span class="ow">and</span> <span class="n">y_1</span><span class="o">+</span><span class="n">y_2</span><span class="o">%</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">O</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="o">!=</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">lamda1</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_2</span> <span class="o">-</span> <span class="n">y_1</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_2</span> <span class="o">-</span> <span class="n">x_1</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="n">inverse</span><span class="p">(</span><span class="n">lamda2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
        <span class="n">lamda</span> <span class="o">=</span> <span class="n">lamda1</span><span class="o">*</span><span class="n">lamda2</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">x_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqr_mod</span><span class="p">(</span><span class="n">lamda</span><span class="p">)</span><span class="o">-</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span>
        <span class="n">y_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">lamda</span><span class="o">*</span><span class="p">((</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_3</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">-</span><span class="n">y_1</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="k">return</span> <span class="p">(</span><span class="n">x_3</span><span class="p">,</span><span class="n">y_3</span><span class="p">)</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="o">==</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">lamda1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">sqr_mod</span><span class="p">(</span><span class="n">x_1</span><span class="p">)</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y_1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="n">inverse</span><span class="p">(</span><span class="n">lamda2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
        <span class="n">lamda</span> <span class="o">=</span> <span class="n">lamda1</span><span class="o">*</span><span class="n">lamda2</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">x_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqr_mod</span><span class="p">(</span><span class="n">lamda</span><span class="p">)</span><span class="o">-</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span>
        <span class="n">y_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">lamda</span><span class="o">*</span><span class="p">((</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_3</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">-</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="k">return</span> <span class="p">(</span><span class="n">x_3</span><span class="p">,</span><span class="n">y_3</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5274</span><span class="p">,</span> <span class="mi">2841</span><span class="p">)</span> 
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8669</span><span class="p">,</span> <span class="mi">740</span><span class="p">)</span>

<span class="c1"># tmp = addition_point(X,X,497)
# print(tmp)
</span><span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">493</span><span class="p">,</span> <span class="mi">5564</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1539</span><span class="p">,</span> <span class="mi">4742</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4403</span><span class="p">,</span><span class="mi">5202</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">addition_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">addition_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">addition_point</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">R</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

<span class="c1">############# 
</span>
<span class="k">def</span> <span class="nf">scalar_multi</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">P</span> 
    <span class="n">R</span> <span class="o">=</span> <span class="n">O</span> 
    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">addition_point</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span> 
        <span class="n">Q</span> <span class="o">=</span> <span class="n">addition_point</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
        <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span> 
    <span class="k">return</span> <span class="n">R</span> 
<span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2339</span><span class="p">,</span> <span class="mi">2213</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">7863</span>
<span class="n">nP</span> <span class="o">=</span> <span class="n">scalar_multi</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">nP</span><span class="p">)</span> 
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag: crypto{9467, 2742}
</code></pre></div></div>

<hr />

<h3 id="curves-and-logs">CURVES AND LOGS</h3>

<p>The Elliptic Curve Discrete Logarithm Problem (ECDLP) is the problem of finding an integer <code class="language-plaintext highlighter-rouge">n</code> such that <code class="language-plaintext highlighter-rouge">Q=nP</code></p>

<p>Like we encounted with the discrete logarithm problem, scalar multiplication of a point in <code class="language-plaintext highlighter-rouge">E(F_p)</code> seems to be be a hard problem to undo, with the most efficient algorithm running at $p^{\frac{1}{2}}$ time.</p>

<p>This makes it a great candidate for a trapdoor function.</p>

<p>Alice and Bob are talking and they want to create a shared secret so they can start encrypting their messages with some symmetric cryptographic protocol.</p>

<p>Alice and Bob don’t trust their connection, so they need a way create a secret others ca’t replicate.</p>

<p>Alice and Bob agree on a curve <code class="language-plaintext highlighter-rouge">E</code>, a prime <code class="language-plaintext highlighter-rouge">p</code> and a generator point <code class="language-plaintext highlighter-rouge">G</code></p>

<p>Note: In elliptic curve cryptographic, it is important that the order of G is prime. Constructing secure curves is complicated and it is recommended to use a preconstructed curve where a client is given the curve, the prime and the generator to use.</p>

<p>Alice generates a secret random integer $n_A$ and calculates $Q_A=n_AG$</p>

<p>Bob generates a secret random integer $n_B$ and calculates $Q_B=n_BG$</p>

<p>Alice sends Bob $Q_A$, and Bob sends Alice $Q_B$. Due to the hardness of <code class="language-plaintext highlighter-rouge">ECDLP</code>, an onlooker Eve is unable to calculate $n_{A\text{ / } B}$ in reasonable time.</p>

<p>Alice then calculates $n_AQ_B$, and Bob calculates $n_BQ_A$.</p>

<p>Due to the associativity of scalar multiplication, $S = n_AQ_B=n_BQ_A$</p>

<p>Alice and Bob can use <code class="language-plaintext highlighter-rouge">S</code> as their shared secret.</p>

<p>Using the curve, prime and generator:</p>

<p>$E: Y^2 = X^3+497X+1769 , p: 9739, G: (1804,5369)$</p>

<p>Calculate the shared secret after Alice sends you $Q_A = (815,3190)$, with your secret integer: $n_B = 1829$</p>

<p>Generate a key by calculating the SHA1 hash of the x coordinate (take the decimal representation of the coordinate and cast it to a string). The flag is the hexdigest you find.</p>

<p>This is my sol</p>

<div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">Crypto.Util.number</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">inf</span> <span class="o">=</span> <span class="mi">1000000000000000000</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">9739</span> 
<span class="n">O</span> <span class="o">=</span> <span class="p">(</span><span class="n">inf</span><span class="o">%</span><span class="n">p</span><span class="p">,</span><span class="n">inf</span><span class="o">%</span><span class="n">p</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sqr_mod</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">%</span><span class="n">p</span>
<span class="k">def</span> <span class="nf">addition_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mi">497</span>
    <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="o">==</span><span class="n">O</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Q</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">Q</span><span class="o">==</span><span class="n">O</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">P</span> 
    <span class="n">x_1</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_1</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x_2</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">y_2</span> <span class="o">=</span> <span class="n">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x_1</span><span class="o">==</span><span class="n">x_2</span> <span class="ow">and</span> <span class="n">y_1</span><span class="o">+</span><span class="n">y_2</span><span class="o">%</span><span class="n">p</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">O</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="o">!=</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">lamda1</span> <span class="o">=</span> <span class="p">(</span><span class="n">y_2</span> <span class="o">-</span> <span class="n">y_1</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_2</span> <span class="o">-</span> <span class="n">x_1</span> <span class="o">+</span> <span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="n">inverse</span><span class="p">(</span><span class="n">lamda2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
        <span class="n">lamda</span> <span class="o">=</span> <span class="n">lamda1</span><span class="o">*</span><span class="n">lamda2</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">x_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqr_mod</span><span class="p">(</span><span class="n">lamda</span><span class="p">)</span><span class="o">-</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span>
        <span class="n">y_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">lamda</span><span class="o">*</span><span class="p">((</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_3</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">-</span><span class="n">y_1</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="k">return</span> <span class="p">(</span><span class="n">x_3</span><span class="p">,</span><span class="n">y_3</span><span class="p">)</span> 
    <span class="k">if</span><span class="p">(</span><span class="n">P</span><span class="o">==</span><span class="n">Q</span><span class="p">):</span>
        <span class="n">lamda1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">sqr_mod</span><span class="p">(</span><span class="n">x_1</span><span class="p">)</span><span class="o">+</span><span class="n">a</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y_1</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">lamda2</span> <span class="o">=</span> <span class="n">inverse</span><span class="p">(</span><span class="n">lamda2</span><span class="p">,</span><span class="n">p</span><span class="p">)</span>
        <span class="n">lamda</span> <span class="o">=</span> <span class="n">lamda1</span><span class="o">*</span><span class="n">lamda2</span><span class="o">%</span><span class="n">p</span> 
        <span class="n">x_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">sqr_mod</span><span class="p">(</span><span class="n">lamda</span><span class="p">)</span><span class="o">-</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_2</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span>
        <span class="n">y_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">lamda</span><span class="o">*</span><span class="p">((</span><span class="n">x_1</span><span class="o">-</span><span class="n">x_3</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span><span class="o">-</span><span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">p</span><span class="p">)</span><span class="o">%</span><span class="n">p</span> 
        <span class="k">return</span> <span class="p">(</span><span class="n">x_3</span><span class="p">,</span><span class="n">y_3</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5274</span><span class="p">,</span> <span class="mi">2841</span><span class="p">)</span> 
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8669</span><span class="p">,</span> <span class="mi">740</span><span class="p">)</span>

<span class="c1"># tmp = addition_point(X,X,497)
# print(tmp)
</span><span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">493</span><span class="p">,</span> <span class="mi">5564</span><span class="p">)</span>
<span class="n">Q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1539</span><span class="p">,</span> <span class="mi">4742</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4403</span><span class="p">,</span><span class="mi">5202</span><span class="p">)</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">addition_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">addition_point</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">addition_point</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">R</span><span class="p">)))</span>
<span class="c1"># print(S)
</span>
<span class="c1">############# 
</span>
<span class="k">def</span> <span class="nf">scalar_multi</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="n">Q</span> <span class="o">=</span> <span class="n">P</span> 
    <span class="n">R</span> <span class="o">=</span> <span class="n">O</span> 
    <span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">addition_point</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span> 
        <span class="n">Q</span> <span class="o">=</span> <span class="n">addition_point</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span><span class="n">Q</span><span class="p">)</span>
        <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span> 
    <span class="k">return</span> <span class="n">R</span> 

<span class="n">nB</span> <span class="o">=</span> <span class="mi">1829</span>
<span class="n">Q_A</span> <span class="o">=</span> <span class="p">(</span><span class="mi">815</span><span class="p">,</span><span class="mi">3190</span><span class="p">)</span>

<span class="n">S</span> <span class="o">=</span> <span class="n">scalar_multi</span><span class="p">(</span><span class="n">Q_A</span><span class="p">,</span><span class="n">nB</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
</code></pre></div></div>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>S = (7929,707)
flag: crypto{SHA1(7929)}
=&gt; flag: crypto{80e5212754a824d3a4aed185ace4f9cac0f908bf}
</code></pre></div></div>

<hr />

<h3 id="efficient-exchange">EFFICIENT EXCHANGE</h3>

<p>Alice and Bob are looking at the Elliptic Curve discrete Logarithm Problem and thinking about the data they send</p>

<p>They want to try and keep their data transfer as efficient as possible and realise that sending both the <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> coordinate of their public key isn’t nessary.</p>

<p>As long as Alice and Bob agree on the curve parameters, there are only ever two possible values of <code class="language-plaintext highlighter-rouge">y</code> for a given <code class="language-plaintext highlighter-rouge">x</code></p>

<p>In fact, given either of the values of <code class="language-plaintext highlighter-rouge">y</code> permissible from the value <code class="language-plaintext highlighter-rouge">x</code> they receive, the <code class="language-plaintext highlighter-rouge">x</code> coordinate of their shared secret will be same</p>

<p>Note: For these challenges, we have used a prime <code class="language-plaintext highlighter-rouge">p = 3 mod 4</code>, which help you find <code class="language-plaintext highlighter-rouge">y</code> from $y^2$</p>

<p>Using the curve, prime and generator:</p>

<p>$E:Y^2=X^3+497X+1769,p:9739,G:(1804,5368)$</p>

<p>Calculate the shared secret after Alice sends you <code class="language-plaintext highlighter-rouge">q_x=4726</code>, with your secret integer $n_B=6534$</p>

<p>Use the <code class="language-plaintext highlighter-rouge">decrypt.py</code> file to decode the flag.</p>

<p><code class="language-plaintext highlighter-rouge">{'iv': 'cd9da9f1c60925922377ea952afc212c', 'encrypted_flag': 'febcbe3a3414a730b125931dccf912d2239f3e969c4334d95ed0ec86f6449ad8}</code></p>

<p>Note: You can specify which of the two</p>


      </article>

      
        <div class="blog-tags">
          <span>Tags:</span>
          
            <a href="/tags#ECC">ECC</a>
          
        </div>
      

      

      
        <!-- Check if any share-links are active -->




<section id = "social-share-section">
  <span class="sr-only">Share: </span>

  
    <a href="https://twitter.com/intent/tweet?text=T%E1%BB%95ng+quan+v%E1%BB%81+ECC&url=http%3A%2F%2Flocalhost%3A4000%2F2021-01-03-ECC%2F"
      class="btn btn-social-icon btn-twitter" title="Share on Twitter">
      <span class="fab fa-fw fa-twitter" aria-hidden="true"></span>
      <span class="sr-only">Twitter</span>
    </a>
  

  
    <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2F2021-01-03-ECC%2F"
      class="btn btn-social-icon btn-facebook" title="Share on Facebook">
      <span class="fab fa-fw fa-facebook" aria-hidden="true"></span>
      <span class="sr-only">Facebook</span>
    </a>
  

  
    <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2F2021-01-03-ECC%2F"
      class="btn btn-social-icon btn-linkedin" title="Share on LinkedIn">
      <span class="fab fa-fw fa-linkedin" aria-hidden="true"></span>
      <span class="sr-only">LinkedIn</span>
    </a>
  

  

</section>



      

      <ul class="pagination blog-pager">
        
        <li class="page-item previous">
          <a class="page-link" href="/2021-01-02-Dai-so-truu-tuong/" data-toggle="tooltip" data-placement="top" title="Đại số trừu tượng">&larr; Previous Post</a>
        </li>
        
        
        <li class="page-item next">
          <a class="page-link" href="/2021-01-04-Demo-tat-nien/" data-toggle="tooltip" data-placement="top" title="Luyện tập Crypto">Next Post &rarr;</a>
        </li>
        
      </ul>
      
  
  
  

  




    </div>
  </div>
</div>


  <footer>
  <div class="container-md beautiful-jekyll-footer">
    <div class="row">
      <div class="col-xl-8 offset-xl-2 col-lg-10 offset-lg-1">
      <ul class="list-inline text-center footer-links"><li class="list-inline-item">
    <a href="/feed.xml" title="RSS">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">RSS</span>
    </a>
  </li><li class="list-inline-item">
    <a href="mailto:tritanngo99@gmail.com" title="Email me">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Email me</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://www.facebook.com/deanattali" title="Facebook">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-facebook fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Facebook</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://github.com/daattali" title="GitHub">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-github fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">GitHub</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://twitter.com/daattali" title="Twitter">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Twitter</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://www.youtube.com/c/daattali" title="YouTube">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-youtube fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">YouTube</span>
   </a>
  </li><li class="list-inline-item">
    <a href="https://patreon.com/DeanAttali" title="Patreon">
      <span class="fa-stack fa-lg" aria-hidden="true">
        <i class="fas fa-circle fa-stack-2x"></i>
        <i class="fab fa-patreon fa-stack-1x fa-inverse"></i>
      </span>
      <span class="sr-only">Patreon</span>
    </a>
  </li></ul>

      
      <p class="copyright text-muted">
      
        Ngô Tấn Trí
        &nbsp;&bull;&nbsp;
      
      2022

      
        &nbsp;&bull;&nbsp;
        <span class="author-site">
          <a href="http://localhost:4000/">MyWebsite.com</a>
        </span>
      

      
      </p>
      <p class="theme-by text-muted">
        Powered by
        <a href="https://beautifuljekyll.com">Beautiful Jekyll</a>
      </p>
      </div>
    </div>
  </div>
</footer>


  
  
    
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha256-4+XzXVhsDmqanXGHaHvgh1gMQKX40OUvDEBTu8JcmNs=" crossorigin="anonymous"></script>


  
    
  <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>


  
    
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>


  



  
    <!-- doing something a bit funky here because I want to be careful not to include JQuery twice! -->
    
      <script src="/assets/js/beautifuljekyll.js"></script>
    
  









</body>
</html>
